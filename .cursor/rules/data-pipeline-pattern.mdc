---
description: Best practices for implementing frontend data pipelines using the store->service->hook pattern
globs: 
alwaysApply: false
---
# Data Pipeline Pattern Rule
  triggers:
    - Creating new data fetching/manipulation features
    - Reviewing or refactoring existing data flows
    - Questions about state management architecture
    - Implementing store/service/hook combinations
    - Debugging issues with data flow or state management
  example_queries:
    - "How should I structure this new data feature?"
    - "Is this the right way to implement this store/hook?"
    - "How do I handle credentials in this flow?"
    - "Where should this business logic go?"
  related_files:
    - "**/*Store.ts"
    - "**/*service.ts"
    - "**/use*.ts"
    - "**/types/**/*.ts"
    
# Data Pipeline Pattern Rule

## Pattern Overview
```mermaid
graph LR
    FE[Frontend Component] --> Hook[Hook Layer]
    Hook --> Store[Store Layer]
    Hook --> ClientService[Client Service Layer]
    ClientService --> InternalAPI[Internal API Route]
    InternalAPI --> ServerService[Server Service Layer]
    ServerService --> ExternalAPI[External API/KIPU]
    Store --> FE
```

## Layer Responsibilities

### 1. Store Layer (State Management)
```typescript
// Example: patientStore.ts
export interface ExampleStore {
  data: DataType[];
  selectedItem: DataType | null;
  isLoading: boolean;
  error: string | null;

  // Actions
  setData: (data: DataType[]) => void;
  selectItem: (item: DataType | null) => void;
  setIsLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
}
```
**Requirements:**
- âœ… Pure state management only
- âœ… No business logic
- âœ… Typed interfaces
- âœ… Simple setters/getters
- âœ… UI state handling (loading, errors)
- âŒ NO API calls
- âŒ NO side effects

### 2. Client Service Layer (API Communication)
```typescript
// Example: medical-records-service.ts (CLIENT)
export async function fetchMedicalRecords(patientId: string): Promise<ApiResponse<DataType>> {
  const response = await fetch(`/api/patients/${patientId}/medical_records`);
  if (!response.ok) throw new Error('Failed to fetch');
  return response.json();
}
```
**Requirements:**
- âœ… Internal API communication only
- âœ… Type safety
- âœ… Error handling
- âœ… Response transformation
- âŒ NO external API calls
- âŒ NO credential management
- âŒ NO store dependencies

### 3. Internal API Route (Backend Entry)
```typescript
// Example: route.ts
export async function GET(req: Request, { params }) {
  const { user } = await auth();
  const credentials = await getKipuCredentials(user);
  const data = await serverService.fetchFromKipu(params.id, credentials);
  return Response.json({ data });
}
```
**Requirements:**
- âœ… Authentication
- âœ… Credential management
- âœ… Error handling
- âœ… Calls server service layer
- âŒ NO direct external API calls
- âŒ NO business logic

### 4. Server Service Layer (External API Communication)
```typescript
// Example: medical-records-service.ts (SERVER)
export async function fetchFromKipu(id: string, credentials: KipuCredentials) {
  // Direct KIPU API calls
  // Data transformation
  // Error handling
  return transformedData;
}
```
**Requirements:**
- âœ… External API communication
- âœ… Credential usage
- âœ… Data transformation
- âœ… Error handling
- âœ… Business logic
- âŒ NO UI concerns

### 5. Hook Layer (Integration)
```typescript
export const useFetchData = (params: Params) => {
  const setData = useStore(state => state.setData);
  const setIsLoading = useStore(state => state.setIsLoading);
  
  const fetchData = useCallback(async () => {
    setIsLoading(true);
    try {
      const data = await clientService.fetchData(params);
      setData(data);
    } catch (error) {
      setError(error.message);
    } finally {
      setIsLoading(false);
    }
  }, [params]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);
};
```
**Requirements:**
- âœ… Bridges UI and client service
- âœ… Store updates
- âœ… Loading/error management
- âŒ NO API calls
- âŒ NO credential handling

## Data Flow
```typescript
Frontend Component
  â†’ Hook (manages UI state)
    â†’ Client Service (calls internal API)
      â†’ Internal API Route (handles auth)
        â†’ Server Service (calls external API)
          â†’ External API/KIPU
```

## Authentication/Credentials
- MUST be handled in Internal API route
- Server Service layer receives credentials from API route
- NEVER exposed to frontend
- Centralized management in backend only

## Implementation Steps

1. Define types in `/types` directory
2. Create server service layer for external API communication
3. Create API routes that use server service
4. Create client service layer for internal API calls
5. Set up store for UI state
6. Create hook to bridge client service and store
7. Use hook and store in components

## Testing Boundaries

### Store Tests
- Test state updates
- Test selector behavior

### Client Service Tests
- Test API call handling
- Test error scenarios
- Mock fetch calls

### Server Service Tests
- Test external API integration
- Test credential handling
- Test data transformation

### Hook Tests
- Test effect triggers
- Test store updates
- Mock client service

### API Route Tests
- Test authentication
- Test error handling
- Mock server service

## Common Anti-Patterns to Avoid

1. âŒ Calling external APIs directly from frontend
2. âŒ Passing credentials through frontend
3. âŒ Mixing client and server service responsibilities
4. âŒ Direct service calls from components
5. âŒ Business logic in stores
6. âŒ UI state in services

## Benefits

- ğŸ”’ Secure credential handling
- ğŸ¯ Clear separation of concerns
- ğŸ“ˆ Predictable data flow
- ğŸ§ª Easy testing boundaries
- ğŸ”§ Maintainable codebase
- ğŸ“¦ Reusable patterns
- ğŸš€ Scalable architecture 